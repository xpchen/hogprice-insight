# 指标解析规则（指标名称 raw_header -> 结构化维度）

> 目标：将 Excel 第二行“指标名称（raw_header）”解析为可查询维度字段，并写入：
> - `dim_metric.metric_group / metric_name / freq / parse_json`
> - `fact_observation.geo_id / company_id / warehouse_id / tags_json`

---

## 1) 输入与输出定义

## 1.1 输入
- `raw_header: str`  
  示例：
  - `商品猪：出栏均价：黑龙江（日）`
  - `外三元猪：每头重110-125kg：出栏价：辽宁：辽宁大北农（日）`
  - `标猪：区域价差：河南-山东（日）`
  - `养殖利润：自繁自养利润（周）`

- `sheet_name: str`（用于优先级推断）
  - 分省区猪价 / 集团企业出栏价 / 交割库出栏价 / 区域价差 / 肥标价差 / 毛白价差 / 养殖利润（周度）

## 1.2 输出（建议统一结构）
```json
{
  "metric_group": "province|group|warehouse|spread|profit",
  "metric_name": "出栏价|出栏均价|区域价差|肥标价差|毛白价差|利润|猪粮比|饲料比价|...",
  "freq": "daily|weekly",
  "geo": "黑龙江",
  "region": "东北",
  "company": "辽宁大北农",
  "warehouse": "xx交割库/库点",
  "tags": {
    "pig_type": "商品猪|外三元|标猪|白条|...",
    "weight_range": "110-125kg",
    "price_type": "均价|报价|...",
    "ma": "7d|30d",
    "pair": "河南-山东",
    "raw_parts": ["..."]
  }
}
```

---

## 2) 标准化预处理（Normalization）

1. 全角/半角统一：`：`、`:` 统一为中文冒号 `：`  
2. 去除多余空格：连续空格 -> 单空格 -> 再去除
3. 频率括号统一：可能出现 `（日）/(日)`、`（周）/(周)`  
4. raw_header 末尾频率括号剥离（后面步骤专门解析）

伪代码：
```py
s = raw_header.strip()
s = s.replace(":", "：")
s = re.sub(r"\s+", " ", s)
```

---

## 3) 频率 freq 解析（最高优先级）

优先从末尾括号提取：

### 3.1 规则
- `...（日）` 或 `...(日)` -> `daily`
- `...（周）` 或 `...(周)` -> `weekly`
- 若无括号：
  - 若 sheet_name 含 “周度/周” -> weekly
  - 否则默认 daily

### 3.2 正则
```py
m = re.search(r"[（(](日|周)[)）]\s*$", s)
```

解析到 freq 后，把括号从字符串尾部移除：
```py
s_wo_freq = re.sub(r"\s*[（(](日|周)[)）]\s*$", "", s)
```

---

## 4) 分段 parts 拆分

以 `：` 分段：
```py
parts = [p.strip() for p in s_wo_freq.split("：") if p.strip()]
```

例：
- `商品猪：出栏均价：黑龙江` -> `["商品猪","出栏均价","黑龙江"]`
- `外三元猪：每头重110-125kg：出栏价：辽宁：辽宁大北农` -> `["外三元猪","每头重110-125kg","出栏价","辽宁","辽宁大北农"]`

若 parts 仍为 1 段，视为“弱结构”：全部塞进 tags.raw_parts，metric_name 由字典推断。

---

## 5) 指标组 metric_group 推断

**优先使用 sheet_name 映射**（推荐，稳定）：

| sheet_name 包含 | metric_group |
|---|---|
| 分省区猪价 | province |
| 集团企业出栏价 | group |
| 交割库出栏价 | warehouse |
| 区域价差 / 肥标价差 / 毛白价差 | spread |
| 养殖利润 | profit |
| 其他/未知 | misc |

---

## 6) 指标名 metric_name 推断（字典匹配）

从 parts 中寻找“指标关键词”，常见映射：

- 价格类：
  - 出栏价、出栏均价、均价、报价、到厂价
- 价差类：
  - 区域价差、肥标价差、毛白价差、基差、贴水、升水
- 利润类（周度）：
  - 自繁自养利润、外购仔猪利润、头均盈利、成本
- 比率类：
  - 猪粮比、饲料比价、料肉比（如果出现）

匹配策略：
1) 遍历 parts，找到最长匹配（避免“价”误匹配）
2) 若无命中：
   - spread 组默认 `价差`
   - profit 组默认 `利润`
   - 否则默认 `价格`

示例字典（可扩展）：
```py
METRIC_KEYWORDS = [
  "区域价差","肥标价差","毛白价差","基差",
  "出栏均价","出栏价","均价","报价",
  "自繁自养利润","外购仔猪利润","养殖利润",
  "猪粮比","饲料比价"
]
```

---

## 7) 维度字段识别规则（geo/company/warehouse/tags）

### 7.1 体重段 weight_range
命中条件：
- 包含 `kg/KG/公斤` 或 包含 `每头重`
- 常见格式：`110-125kg`、`110～125kg`、`110—125kg`

正则：
```py
m = re.search(r"(\d+\s*[-—～]\s*\d+\s*kg)", p, re.I)
```

标准化：
- 将 `—/～` 统一为 `-`
- 小写 `kg`
- 去除空格

输出：
- tags.weight_range = "110-125kg"

### 7.2 猪种 pig_type（tags.pig_type）
命中条件：
- part 中含 `猪` 或命中白名单：`标猪/商品猪/外三元/内三元/土杂/白条/肥猪/仔猪`
- 优先使用第一段（很多表第一段就是猪种）

输出：
- tags.pig_type = ...

### 7.3 地区 geo（province）
命中条件（优先级）：
1) 如果 metric_group=province：最后一段通常是省（如 黑龙江）
2) 如果 metric_group=group：倒数第2段通常是省（如 辽宁）
3) 如果出现明确省份列表命中（建议维护 PROVINCE_SET）
4) 如果 part 是区域名（东北/华东...），写入 region

> 建议维护省份名单：34 个省级行政区 + 常用地区写法（如 内蒙古/广西/宁夏/新疆/西藏）

### 7.4 企业 company
命中条件：
- metric_group=group：最后一段通常是企业名
- 企业名通常不在省份名单中，且长度>=3
- 若包含公司关键字：`集团/股份/农牧/食品/牧业/发展/有限/公司/大北农/双汇...`

输出：
- company = part

### 7.5 交割库/库点 warehouse
命中条件：
- metric_group=warehouse：最后一段或倒数第一/二段可能是库点
- 关键词：`交割库/屠宰/冷库/库/点/场`
- 或 sheet 固定“交割库出栏价”时，把末段当 warehouse

输出：
- warehouse = part

### 7.6 价差对 pair（tags.pair）
- 区域价差常出现：`河南-山东` 或 `豫-鲁`
- 正则：
```py
m = re.search(r"(.+?)[-—～](.+)", p)
```
输出：
- tags.pair = "河南-山东"

---

## 8) 解析优先级总流程（推荐实现）

```text
raw_header + sheet_name
  -> normalize
  -> parse freq, strip tail
  -> split parts
  -> metric_group from sheet_name
  -> metric_name from keyword match on parts
  -> extract weight_range (tags)
  -> extract pig_type (tags)
  -> extract pair (tags)
  -> infer geo/company/warehouse by metric_group & province set
  -> pack parse_json（包含原 parts）
```

---

## 9) 失败兜底策略（必须）

如果解析不出关键维度，不要丢数据：
- dim_metric.parse_json.tags.raw_parts = parts
- dim_metric.metric_name 使用默认值（按 group）
- fact_observation.tags_json 写入 `{"raw_parts": [...], "raw_header": "..."}`
- geo/company/warehouse 为空也允许入库

---

## 10) 建议：先做可运行的“最小解析器”

MVP 解析器目标：
- freq 100% 正确
- metric_group 100% 正确（sheet_name映射）
- metric_name 80% 正确（关键词字典）
- group：能抽出 company + province
- province：能抽出 province
- spread：能抽出 pair（若存在）
- profit：能识别利润/猪粮比等关键词

后续再增强：
- region 映射
- 交割库识别词典
- 企业别名归一（如 “大北农” vs “辽宁大北农”）

---

## 11) 可直接抄用的代码骨架（示意）

```py
import re

PROVINCES = {...}  # 省份集合
REGIONS = {"东北","华北","华东","华中","华南","西南","西北"}

METRIC_KEYWORDS = [
  "区域价差","肥标价差","毛白价差","基差",
  "出栏均价","出栏价","均价","报价",
  "自繁自养利润","外购仔猪利润","养殖利润",
  "猪粮比","饲料比价"
]

def parse_header(raw_header: str, sheet_name: str) -> dict:
    s = (raw_header or "").strip().replace(":", "：")
    s = re.sub(r"\s+", " ", s)

    # freq
    m = re.search(r"[（(](日|周)[)）]\s*$", s)
    if m:
        freq = "daily" if m.group(1) == "日" else "weekly"
        s = re.sub(r"\s*[（(](日|周)[)）]\s*$", "", s)
    else:
        freq = "weekly" if ("周" in (sheet_name or "")) else "daily"

    parts = [p.strip() for p in s.split("：") if p.strip()]

    metric_group = infer_group(sheet_name)
    metric_name = infer_metric_name(parts, metric_group)

    tags = {"raw_parts": parts}

    # weight
    for p in parts:
        m = re.search(r"(\d+\s*[-—～]\s*\d+\s*kg)", p, re.I)
        if m:
            w = m.group(1)
            w = re.sub(r"\s+", "", w).replace("—","-").replace("～","-").lower()
            tags["weight_range"] = w
            break

    # pair
    for p in parts:
        if any(k in p for k in ["价差","基差"]) and re.search(r".+[-—～].+", p):
            pair = p.replace("—","-").replace("～","-")
            tags["pair"] = pair
            break

    # pig_type
    pig_candidates = ["标猪","商品猪","外三元","内三元","土杂","白条","仔猪","肥猪"]
    if parts:
        if "猪" in parts[0] or parts[0] in pig_candidates:
            tags["pig_type"] = parts[0].replace("猪","猪")

    geo = company = warehouse = None

    if metric_group == "province":
        if parts:
            last = parts[-1]
            if last in PROVINCES:
                geo = last
    elif metric_group == "group":
        if len(parts) >= 2:
            maybe_company = parts[-1]
            maybe_geo = parts[-2]
            if maybe_geo in PROVINCES:
                geo = maybe_geo
            company = maybe_company
    elif metric_group == "warehouse":
        warehouse = parts[-1] if parts else None
        # 省份可能在倒数第二段
        if len(parts) >= 2 and parts[-2] in PROVINCES:
            geo = parts[-2]
    elif metric_group == "spread":
        # spread 通常无 geo/company，靠 pair 或其它 tags
        pass
    elif metric_group == "profit":
        pass

    return {
        "metric_group": metric_group,
        "metric_name": metric_name,
        "freq": freq,
        "geo": geo,
        "company": company,
        "warehouse": warehouse,
        "tags": tags
    }
```

